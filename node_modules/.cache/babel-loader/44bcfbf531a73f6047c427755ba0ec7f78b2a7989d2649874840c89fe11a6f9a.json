{"ast":null,"code":"/* // array in local storage for registered users\nlet users = JSON.parse(localStorage.getItem('customer')) || [];\n    \nexport function configureFakeBackend() {\n    debugger;\n    let realFetch = window.fetch;\n    window.fetch = function (url, opts) {\n        const { method, headers } = opts;\n        const body = opts.body && JSON.parse(opts.body);\n\n        return new Promise((resolve, reject) => {\n            // wrap in timeout to simulate server api call\n            setTimeout(handleRoute, 500);\n\n            function handleRoute() {\n                switch (true) {\n                    case url.endsWith('/customers/login') && method === 'POST':\n                        return authenticate();\n                    case url.endsWith('/customers/register') && method === 'POST':\n                        return register();\n                    case url.endsWith('/customers/') && method === 'GET':\n                        return getUsers();\n                    case url.match(/\\/users\\/\\d+$/) && method === 'DELETE':\n                        return deleteUser();\n                    default:\n                        // pass through any requests not handled above\n                        return realFetch(url, opts)\n                            .then(response => resolve(response))\n                            .catch(error => reject(error));\n                }\n            }\n\n            // route functions\n\n            function authenticate() {\n                const { username, password } = body;\n                const user = users.find(x => x.username === username && x.password === password);\n                if (!user) return error('Username or password is incorrect');\n                return ok({\n                    id: user.id,\n                    username: user.username,\n                    firstName: user.firstName,\n                    lastName: user.lastName,\n                    token: 'fake-jwt-token'\n                });\n            }\n\n            function register() {\n                const user = body;\n    \n                if (users.find(x => x.username === user.username)) {\n                    return error(`Username  ${user.username} is already taken`);\n                }\n    \n                // assign user id and a few other properties then save\n                user.id = users.length ? Math.max(...users.map(x => x.id)) + 1 : 1;\n                users.push(user);\n                localStorage.setItem('users', JSON.stringify(users));\n\n                return ok();\n            }\n    \n            function getUsers() {\n                if (!isLoggedIn()) return unauthorized();\n\n                return ok(users);\n            }\n    \n            function deleteUser() {\n                if (!isLoggedIn()) return unauthorized();\n    \n                users = users.filter(x => x.id !== idFromUrl());\n                localStorage.setItem('users', JSON.stringify(users));\n                return ok();\n            }\n\n            // helper functions\n\n            function ok(body) {\n                resolve({ ok: true, text: () => Promise.resolve(JSON.stringify(body)) });\n            }\n\n            function unauthorized() {\n                resolve({ status: 401, text: () => Promise.resolve(JSON.stringify({ message: 'Unauthorized' })) });\n            }\n\n            function error(message) {\n                resolve({ status: 400, text: () => Promise.resolve(JSON.stringify({ message })) });\n            }\n\n            function isLoggedIn() {\n                return headers['Authorization'] === 'Bearer fake-jwt-token';\n            }\n    \n            function idFromUrl() {\n                const urlParts = url.split('/');\n                return parseInt(urlParts[urlParts.length - 1]);\n            }\n        });\n    }\n} */","map":{"version":3,"names":[],"sources":["C:/Users/Tringle7/Documents/PersonalWorkspace/programschedule-web/src/_helpers/fake-backend.js"],"sourcesContent":["/* // array in local storage for registered users\nlet users = JSON.parse(localStorage.getItem('customer')) || [];\n    \nexport function configureFakeBackend() {\n    debugger;\n    let realFetch = window.fetch;\n    window.fetch = function (url, opts) {\n        const { method, headers } = opts;\n        const body = opts.body && JSON.parse(opts.body);\n\n        return new Promise((resolve, reject) => {\n            // wrap in timeout to simulate server api call\n            setTimeout(handleRoute, 500);\n\n            function handleRoute() {\n                switch (true) {\n                    case url.endsWith('/customers/login') && method === 'POST':\n                        return authenticate();\n                    case url.endsWith('/customers/register') && method === 'POST':\n                        return register();\n                    case url.endsWith('/customers/') && method === 'GET':\n                        return getUsers();\n                    case url.match(/\\/users\\/\\d+$/) && method === 'DELETE':\n                        return deleteUser();\n                    default:\n                        // pass through any requests not handled above\n                        return realFetch(url, opts)\n                            .then(response => resolve(response))\n                            .catch(error => reject(error));\n                }\n            }\n\n            // route functions\n\n            function authenticate() {\n                const { username, password } = body;\n                const user = users.find(x => x.username === username && x.password === password);\n                if (!user) return error('Username or password is incorrect');\n                return ok({\n                    id: user.id,\n                    username: user.username,\n                    firstName: user.firstName,\n                    lastName: user.lastName,\n                    token: 'fake-jwt-token'\n                });\n            }\n\n            function register() {\n                const user = body;\n    \n                if (users.find(x => x.username === user.username)) {\n                    return error(`Username  ${user.username} is already taken`);\n                }\n    \n                // assign user id and a few other properties then save\n                user.id = users.length ? Math.max(...users.map(x => x.id)) + 1 : 1;\n                users.push(user);\n                localStorage.setItem('users', JSON.stringify(users));\n\n                return ok();\n            }\n    \n            function getUsers() {\n                if (!isLoggedIn()) return unauthorized();\n\n                return ok(users);\n            }\n    \n            function deleteUser() {\n                if (!isLoggedIn()) return unauthorized();\n    \n                users = users.filter(x => x.id !== idFromUrl());\n                localStorage.setItem('users', JSON.stringify(users));\n                return ok();\n            }\n\n            // helper functions\n\n            function ok(body) {\n                resolve({ ok: true, text: () => Promise.resolve(JSON.stringify(body)) });\n            }\n\n            function unauthorized() {\n                resolve({ status: 401, text: () => Promise.resolve(JSON.stringify({ message: 'Unauthorized' })) });\n            }\n\n            function error(message) {\n                resolve({ status: 400, text: () => Promise.resolve(JSON.stringify({ message })) });\n            }\n\n            function isLoggedIn() {\n                return headers['Authorization'] === 'Bearer fake-jwt-token';\n            }\n    \n            function idFromUrl() {\n                const urlParts = url.split('/');\n                return parseInt(urlParts[urlParts.length - 1]);\n            }\n        });\n    }\n} */"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}